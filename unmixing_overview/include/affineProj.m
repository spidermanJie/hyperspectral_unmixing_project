function [yp,Up,my,angles,scales] = affineProj(y,p,varargin)
%%
% Usage:
% [yp,Up,my,sing_val] = affineProj(y,p,varargin)
%
% 
% affineProj estimates and/or projects the data set on an affine set 
% ensuring that the sum-to-one-constraint holds.
%
% observation model
%
%     y = M*x+noise
%
% where M is the mixing matrix containing the endmembers, x is the
% the fractions (sources) of each endmember at each pixel, and noise is a
% an  additive perturbation.
%
% projections: 
%    
%      orth -> finds the best affine set of dimension p-1, in the l2 sense, 
%              and computes the orthogonal projection onto the estimated
%              affine set
%
%      dpft -> finds the best subspace of dimension p, in the l2 sense, 
%              projects the data set on this subspace and then applies
%              a perpecstive projection.
% 
% 
% Author: Jose Bioucas-Dias, January, 2012.
% 
%
% -----------------------------------------------------------------------
% Copyright (2012): Jose Bioucas-Dias
% 
% affineProj is distributed under the terms of 
% the GNU General Public License 2.0.
% 
% Permission to use, copy, modify, and distribute this software for
% any purpose without fee is hereby granted, provided that this entire
% notice is included in all copies of any software which is or includes
% a copy or modification of this software and in all copies of the
% supporting documentation for such software.
% This software is being provided "as is", without any express or
% implied warranty.  In particular, the authors do not make any
% representation or warranty of any kind concerning the merchantability
% of this software or its fitness for any particular purpose."
% ----------------------------------------------------------------------

% 
%
%  =====================================================================
%  ===== Required inputs ===============================================
%
%  y [Lxn] = noisy data set generated by a [Lxp] endmember matrix
%     
%  p  = number of endmembers (then the signal affine dimension is (p-1))
%
%  ===== Optional inputs =============
% 
%  
%  'proj_type' ->  projection type  {'orth','dpft'}: Default: 'orth' 
%   
%
%     'orth' ->   Best (p-1)-dimensional affine set in the l2 sense. 
%                 Infers an isometric matrix, U_{p-1}, of dimension L*(p-1), 
%                 and a vector b of size L miminimzing  ||y-yp||_F, where 
%                 yp=U_{p-1}*U_{p-1}'*(y-b)+b, is minimized.
%
%                 Matrix U_{p-1} corresponds to the first (p-1) columns
%                 of the returned  matrix  Up, which  spans the p-dimensional  
%                 subspace  where  vectors yp lives.
%                            
%
%     'dpft' ->  Dark point fixed transform (perspective projection).
%
%                1) Infers an isometric matrix, U_p, of dimension L*p, 
%                   miminimzing  ||y-yp||_F, where yp=U_p*Up'*y is minimized.
%                
%                2) Scale the abserved vectors: y -> y/(u^T*y), 
%                   where u is a given  fixed vector. This tranformation  
%                   bring  the observed vectors to an affine set 
%                   (an hyperplane) by applying the scale factor 1/((u^T*y).
%
%
%      'u' ->    Vector u used in the perspective projection
%
%                Default:  (L,1)/(ones(L,1)'*my),
%                where my = mean(y,2) is the  data set mean vector.
%  
%                This choise ensures that any angles > 0 for any spectral
%                vector with non-negative components and that the affine
%                set contains the vector my.
%
%      
%
%
% ========================================================================
% =============================== Outputs ===============================
%
%   yp --> [pxsamp_size] projected data set
%
%   Up -->  [Lxp] isometric matrix:  yp-Up*Up'*yp = 0       
%   my -->  data set mean value
%
%   angles --> angles (degress) between unprojected and  projecetd data. 
%              In SU applications  these angles should be close to zero, 
%              since, otherwise, the spectral shapes are distorted.
%              In the 'dpft' projection, angles are in {0,180}.
%  
%   scales --> scales between unprojected and  projecetd data. In SU 
%              applications  scales are not as important and angles.
%
%  
%  Note: in the 'orth' case: yp = Up(:,1:p-1)*Up(:,1:p-1)'*(yp-my) + my;
%        i.e., the couple (Up(:,1:p-1)*Up(:,1:p-1)', my) defines the (p-1)
%        dimensional affine set in which the signal component of y lives.
%
% ========================================================
%    
% ===================================================  
% ============ Call examples ==============================
%
%  yp =dataProj(y,p)
%
%  [yp,Up,my,angles, scales] = dataProj(y,p,'proj_type', 'orth')
%
%  [yp,Up,my] = dataProj(y,p,'proj_type', 'dpdt')
%
%  [yp,Up,my] = dataProj(y,p,'proj_type', 'dpdt', 'u', z)
%
% 
%





%%
%--------------------------------------------------------------
% test for number of required parametres
%--------------------------------------------------------------
if (nargin-length(varargin)) ~= 2
     error('Wrong number of required parameters');
end

% endmember matrix size 
[L,samp_size] = size(y); %((L-> number of bands, samp_sise -> sample size)


%--------------------------------------------------------------
% Set the defaults for the optional parameters
%--------------------------------------------------------------

proj_type   = 'orth';
% mean data set
my = mean(y,2);
% default dpft direction
u = ones(L,1)/(ones(L,1)'*my);

%--------------------------------------------------------------
% Read the optional parameters
%--------------------------------------------------------------
if (rem(length(varargin),2)==1)
  error('Optional parameters should always go by pairs');
else
  for i=1:2:(length(varargin)-1)
    switch upper(varargin{i})
     case 'PROJ_TYPE'
       proj_type = varargin{i+1};
     case 'U'
         u = varargin{i+1};
     otherwise
      % Hmmm, something wrong with the parameter string
      error(['Unrecognized option: ''' varargin{i} '''']);
    end;
  end;
end
%%%%%%%%%%%%%%

%% projections 
 switch  proj_type
    case 'ml'
        % compute the p largest singular values and the
        % corresponding singular vectors
        [Up,D] = svds(y*y'/samp_size,p);   
        sing_val = diag(D);  
        % project onto the subspace span{E}
        yp = Up'*y;             
    case 'orth'
        yp = y-repmat(my,1,samp_size);
        [Up,D] = svds(yp*yp'/samp_size,p-1);         
        % represent yp in the subspace R^(p-1) 
        yp = Up'*yp;   
        % compute the orthogonal component of my
        my_ortho = my-Up*Up'*my;
        % define the p-th orthonormal direction
        Up = [Up my_ortho/sqrt(sum(my_ortho.^2))];
        % compute my coordinates wrt Up
        myp = Up'*my;
        yp(end+1, end) = 0;     % augmented dimension
        % lift yp to R^p
        yp = yp + repmat(myp,1,samp_size);
     case 'dpft'  
        % compute the p largest singular values and the
        % corresponding singular vectors
        [Up,D] = svds(y*y'/samp_size,p);   
        % project onto the subspace span{E}
        yp = Up'*y;    
        % perpective projection  
        yp = yp./repmat((Up'*u)'*yp, p,1);

 end
 
% compute angles and scales
 norm_y = sqrt(sum(y.^2));
 norm_yp = sqrt(sum(yp.^2));
 % we take the real part as, due to numerical  errors,
 % some cosines may be higher than one yielding complex angles 
 angles = real(acos(sum(yp.*(Up'*y))./(norm_yp.*norm_y)))*180/pi;
 scales = norm_yp./norm_y;
 
 

        

return




